<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling · Plasmo.jl - Platform for Scalable Modeling and Optimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Plasmo.jl - Platform for Scalable Modeling and Optimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li><li class="current"><a class="toctext" href>Modeling</a><ul class="internal"><li><a class="toctext" href="#Constructor-1">Constructor</a></li><li><a class="toctext" href="#Adding-Nodes-1">Adding Nodes</a></li><li><a class="toctext" href="#Adding-LinkConstraints-1">Adding LinkConstraints</a></li><li><a class="toctext" href="#Subgraph-Structures-1">Subgraph Structures</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li></ul></li><li><a class="toctext" href="../partitioning/">Partitioning</a></li><li><a class="toctext" href="../manipulation/">Manipulation</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../../tutorials/tutorials/">Tutorials</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Modeling</a></li></ul><a class="edit-page" href="https://github.com/jalving/Plasmo.jl/blob/master/docs/src/documentation/modelgraph.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modeling</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ModelGraph-1" href="#ModelGraph-1">ModelGraph</a></h1><h2><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h2><p>The <code>ModelGraph</code> is the primary object for creating graph-based models in Plasmo.jl.  A <code>ModelGraph</code> extends the <code>JuMP.AbstractModel</code> and offers a collection of <code>ModelNode</code>s (which also extend <code>JuMP.AbstractModel</code>) which represent solvable optimization problems. <code>ModelNode</code>s are connected by <code>LinkConstraint</code>s over variables which induce underlying <code>LinkEdge</code>s.  s</p><p>A <code>ModelGraph</code> does not require any arguments to construct:</p><pre><code class="language-julia">mg = ModelGraph()</code></pre><p>A <code>ModelGraph</code> optimizer can be specified in the same way as in JuMP using <code>set_optimizer(::ModelGraph)</code>.  An optimizer can be any JuMP compatible solver or a custom Plasmo.jl provided solver (see the solvers section).   For example, we could construct a <code>ModelGraph</code> that uses the <code>IpoptSolver</code> from the Ipopt package:</p><pre><code class="language-julia">graph = ModelGraph()
ipopt = Ipopt.Optimizer
set_optimizer(graph,ipopt)</code></pre><h2><a class="nav-anchor" id="Adding-Nodes-1" href="#Adding-Nodes-1">Adding Nodes</a></h2><p><code>ModelNode</code>s can be added to a <code>ModelGraph</code> using the <code>@node</code> macro.  For instance, the below piece of code add the node <code>n1</code> to the modelgraph <code>mg</code></p><pre><code class="language-julia">@node(mg,n1)</code></pre><p>It is also possible to create sets of <code>ModelNode</code>s in a single call to <code>@node</code> like shown in the below code snippet. This example creates a 2x2 grid of modelnodes.</p><pre><code class="language-julia">@node(mg,nodes[1:2,1:2])
for node in nodes
    @variable(node,x&gt;=0)
end</code></pre><p>We can iterate over the nodes in a <code>ModelGraph</code> using the <code>getnodes</code> function.  For example</p><pre><code class="language-julia">for node in getnodes(mg)
    println(node)
end</code></pre><p>will print the string for every node in the <code>ModelGraph</code> graph.  </p><p>Variables within a <code>ModelNode</code> can be accessed directly from their enclosing node.  </p><pre><code class="language-julia">@variable(n1,x &gt;= 0)
println(n1[:x])    #accesses variable x on jump_model</code></pre><h2><a class="nav-anchor" id="Adding-LinkConstraints-1" href="#Adding-LinkConstraints-1">Adding LinkConstraints</a></h2><p><code>LinkConstraint</code>s are linear constraints that couple variables across different <code>ModelNode</code>s.  The simplest way to add <code>LinkConstraint</code>s is to use the <code>@linkconstraint</code> macro.  This macro accepts the same input as a JuMP <code>@constraint</code> macro and creates linear constraints over multiple nodes within the same graph.</p><pre><code class="language-julia">@variable(nodes[1,1],x &gt;= 0)

@linkconstraint(graph,n1[:x] == nodes[1,1][:x])  #creates a linear constraint between nodes n1 and n2</code></pre><h2><a class="nav-anchor" id="Subgraph-Structures-1" href="#Subgraph-Structures-1">Subgraph Structures</a></h2><p>It is possible to create subgraphs within a <code>ModelGraph</code> object.  This is helpful when a user wants to develop to separate systems and link them together within a higher level graph.</p><pre><code class="language-julia">sg1 = ModelGraph()
@node(sg1,nsubs1[1:2])
for node in nsub
    @variable(node,y[1:2] &gt;= 0 )
end
@linkconstraint(sg1,nsubs1[:y][1] == nsubs1[:y][2])  #creates a linear constraint between nodes n1 and n2

sg2 = ModelGraph()
@node(sg2,nsubs2[1:2])
for node in nsub
    @variable(node,y[1:2] &gt;= 0 )
end
@linkconstraint(sg2,nsubs2[:y][1] == nsubs2[:y][2])  #creates a linear constraint between nodes n1 and n2

add_subgraph!(mg,sg1)
add_subgraph!(mg,sg2)

@linkconstraint(mg,nsubs1[:y][2]) == nsubs2[:y][2])</code></pre><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><h3><a class="nav-anchor" id="ModelGraph-2" href="#ModelGraph-2">ModelGraph</a></h3><p>The <code>ModelGraph</code> contains the following useful methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Plasmo.ModelGraph" href="#Plasmo.ModelGraph"><code>Plasmo.ModelGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ModelGraph()</p><p>The ModelGraph Type.  Represents a graph containing models (nodes) and the linkconstraints (edges) between them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/85084e721a9dc6900cf7e3fe097b148bb63c83c2/src/modelgraph.jl#L4-L8">source</a></section><h3><a class="nav-anchor" id="ModelNode-1" href="#ModelNode-1">ModelNode</a></h3><p><code>ModelNode</code>s contain methods for managing their contained JuMP models.</p><pre><code class="language-none">Plasmo.ModelNode
Plasmo.@node(graph::ModelGraph)</code></pre><h3><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h3><pre><code class="language-none">Plasmo.getnodes
Plasmo.all_nodes
Plasmo.getlinkconstraints
Plasmo.all_linkconstraints</code></pre><footer><hr/><a class="previous" href="../quickstart/"><span class="direction">Previous</span><span class="title">Quick Start</span></a><a class="next" href="../partitioning/"><span class="direction">Next</span><span class="title">Partitioning</span></a></footer></article></body></html>
